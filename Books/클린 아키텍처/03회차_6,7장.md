# 6장, 함수형 프로그래밍

### 함수형 프로그래밍의 차이점
(함수형 언어, 클로저를 대상으로)
* 변수는 한번 초기화되면 절대로 변하지 않는다
* 클로저의 문법
    * 괄호안에 함수명을 쓴 뒤 뒤에 인자를 쓴다
    ```c#
    (println (* x x)) = printf(x * x)
    ```
    * 함수를 겹겹이 쓰는 형태인듯

### 불변성과 아키텍처
* 멀티 스레드에서 사용하는 락을 안 써도 된다
* 불변성이 정말 실현 가능한가?
    * 저장 공간이 무한해야함
    * 프로세서의 속도가 무한히 빨라야함
    * -> 타협이 필요

### 가변성의 분리
```c#
    (def counter (atom 0)); //counter라는 변수를 선언 atom 형식은 값변경시 무조건 swap! 함수를 호출필요
    (swap! counter inc) //swap! (변수) (계산식, inc = 1을더하는 함수)
```
* swap! 개념의 설명에서 이해가 잘 안됨
    * counter의 값을 읽은 후 inc 함수로 전달
    * inc 함수 반환시 counter의 값을 잠금 -> 이 잠금의 뜻이 메모리 접근 잠금인가?, 다른 언어의 락개념과 무엇이 다른건가
    * inc 함수로 전달했던 값과 비교
    * 만약 같다면 counter에 저장후 잠금해제, 다르다면 처음부터 재시도 -> 전달했던 값이랑 반환 값이 왜 같아야하는건가
    * -> (어? 그럼 무한반복아닌가..?)

### 이벤트 소싱
* 변수의 값의 변경시 값을 바꾸지 않고 변경식 자체를 저장함
* 시간이 지날수록 계산식이 끝없이 증가하는 문제
* 하지만 애플리케이션의 수명주기가 짧다면 나쁘지않다
    * 소스 코드 버전 관리 시스템이 이 방식으로 동작
    * 비트코인도 이 방식인가..?

# 7장, SRP: 단일 책임 원칙
* 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
* 하나의 모듈은 오직 하나의 사용자에 대해서만 책임져야한다.
    * 모듈의 정의는 대부분 소스 파일이다.
    * 사용자는 여기서 해당 변경을 요청하는 한 명 이상의 사람들을 가리킨다.

### 결론 
* 각자 다른 일을 맡은 여러 사용자(Actor)를 다루는 하나의 클래스에 대한 해결책
* 여러 다른 역할의 사용자는 서로의 존재를 몰라야한다.
* 한 클래스에서 여러 다른 역할의 클래스를 관리하지 말자

### 예시
* 서로 다른 역할의 사용자가 같은 클래스를 사용할때 원치않는 함수 변경,추가에 대한 해결 방법
* 같은 클래스의 함수들을 각기 다른 클래스로 이동해라
* 각기 다른 클래스에서 데이터 구조 클래스를 공유해라

### 퍼사드 패턴
https://lktprogrammer.tistory.com/42
