# 15장, 아키텍처란?

### 요약
* 소프트웨어 시스템의 아키텍처란 시스템을 구축한 사람들이 만들어낸 시스템의 형태이다.
    * 컴포넌트를 분할하는 방법, 분할된 컴포넌트를 배치하는 방법 , 컴포넌트들의 의사소통방법 ... 모든것
* 아키텍처의 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 생산성을 최대화하는 데 있다
* 대게 아키텍처는 운영보다는 배포, 유지보수, 계속되는 개발 과정에서 어려움을 겪는다

### 개발
* 팀 구조가 다르다면 아키텍처 관련 결정에서 차이가 난다
    * 팀의 개발자가 적다면 서로 효율적으로 협력하여 오히려 아키텍처가 방해가 될수 있다.
    * 개발자가 많다면 언정되고 잘 설계된 컴포넌트 단위로 분리하지 않으면 개발이 진척되지 않는다.
    
### 배포
* 배포 비용이 높을수록 시스템의 유용성은 떨어진다.
* 소프트웨어 아키텍처는 시스템을 한번에 배포할 수 있도록 만드는데 목표를 둬야한다.
* 마이크로서비스 아키텍처를 사용하기로 할 경우 배포 시기에 위협적일 만큼 많은 마이크로서비스를 구현하게 될지도 모른다.
* [마이크로 서비스](http://guruble.com/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4microservice-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B7%B8%EA%B2%83%EC%9D%B4-%EB%AD%A3%EC%9D%B4-%EC%A4%91%ED%97%8C%EB%94%94/)

### 운영
* 운영의 대다수의 어려움은 아키텍처에 극적인 영향을 주지 않고 하드웨어 투입으로 해결할 수 있다.
* 비용적인 관점에서 개발, 배포, 유지보수 쪽보다 비용이 덜 든다.
* 좋은 아키텍처는 시스템을 운영하는 데 필요한 요구도 알려준다.

### 유지보수
* 모든 측면에서 비용이 가장 많이 든다.
* 유지보수의 가장 큰 비용은 탐사와 이로 인한 위험부담에 있다.
    * 탐사란 새로운 기능 추가 , 결함 수정, 전략의 결정에 드는 비용이다.
* 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리한다면 의도치 않은 장애의 발생위험을 줄일수 있다.

### 선택사항 열어두기
* 소프트웨어를 유연하게하는 방법은 선택사항을 가능한 많이, 가능한 오랫동안 열어 두는 것이다.

### 결론
* 좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결하보디지 않도록 엄격하게 분리한다.
* 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 미룰 수 있는 방향으로 정책을 설계한다.
* 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화 한다.

# 16장, 독립성

좋은 아키텍처는 다음을 지원해야 한다.
* 시스템의 유스케이스
* 시스템의 운영
* 시스템의 개발
* 시스템의 배포

### 유스케이스
* 시스템의 아키텍처는 시스템의 의도를 지원해야한다는 뜻이다.
    * 만약 시스템이 장바구니 애플리케이션이라면, 이 아키텍처는 장바구니와 관련된 유스케이스를 지원해야한다.
* [유스케이스란](https://m.blog.naver.com/PostView.nhn?blogId=suresofttech&logNo=220845781030)

### 운영
* 시스템의 운영 지원 관점에서 볼때 아키텍처는 더 실질적인 역할을 맡는다.
* 예를 들어 시스템에서 수 밀리초 안에 빅데이터 테이블에 질의해야한다면, 이게 가능한 형태로 구조화해야한다.
    * 서로 많은 서버에서 병렬로 실행하는 방법
    * 경량의 수많은 스레드가 단인 프로세서에서 주소 공간을 공유하는 방법
    * ...

### 개발
* 콘웨이의 법칙이 작용하는 지점이다.
'''
시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.
'''
* 많은 팀으로 구성된다면, 각 팀이 독립적으로 행동할수 있는 아키텍처를 확보해 서로 방해하지 않도록 해야한다.

### 배포
* 좋은 아키텍처는 즉각적인 배포를 해야한다.
    * 위배되는 예시)
    * 속성 파일을 약간씩 수정하거나
    * 필요한 디렉터리나 파일을 수작업으로 생성하거나
* 시스템을 컴포넌트 단위로 적절하게 분할하고 격리시켜야한다.
* 마스터 컴포넌트는 각 컴포넌트를 올바르게 구동하고 통합하고 관리해야한다.

### 선택사항 열어놓기
* 시스템이 생명주기를 거쳐감에 따라 요구사항이 달라진다.
* 선택사항을 열어둠으로써, 향후 시스템에 변경이 필요할때 어떤 방향으로든 쉽게 변경가능하게 한다.

### 계층 결합 분리
* 서로 다른 유형의 규칙은 분리하고 , 독립적으로 변경할 수 있도록 만들어야한다.

### 결합 분리 모드
* 유스케이스를 위해 수행하는 결합 분리는 운영에 도움이 된다.
* 하지만 운영 측면에서 이점을 살리기 위해선 결합을 분리할때 적절한 모드를 선택해야한다.

### 개발 독립성
* 컴포넌트가 완전히 분리되면 팀 사이의 간섭은 줄어든다.

### 배포 독립성
* 유스케이스와 계층의 결합이 분리되면 배포 측면에서 유연성이 생긴다.
* 제대로 분리했다면 운영중인 시스템에서도 계층과 유스케이스를 교체할수있다.

### 중복
* 자동 반사적으로 중복을 제거하려는 유혹을 떨쳐내라
* 중복이 진짜 중복인지 확인하라

### 결합분리 모드 (다시)
* 소스 수준 분리 모드
    * 하나의 모듈이 변하더라도 다른 모듈을 변경하거나 재컴파일 안할수있다 (예시, 루비 언어)
* 배포 수준 분리 모드
    * jar, DLL, lib 같이 배포가능한 단위들 사이의 의존성을 제어할수 있다.
* 서비스 수준 분리 모드
    * 의존하는 수준을 데이터 구조단위까지 낮추고 패킷을 통해서만 통신하도록 만들수잇다 (예시, 서비스 또는 마이크로서비스)
    
* 개발, 배포, 운영적인 문제가 증가하면 서비스 수준으로 전환할 배포 단위들을 신중하게 선택후, 이 방향으로 시스템을 변경해 나간다.







