# 31장, 웹은 세부사항이다.

### 요약

* 웹은 GUI다. GUI는 세부사항이다.
* 아키텍트라면 세부사항을 핵심 업무 로직에서 분리된 바깥에 둬야한다.
* 웹은 입출력 장치다, 애플리케이션은 장치 독립적으로 만들어야한다. 웹도 예외일수 없다.

# 32장, 프레임워크는 세부사항이다.

* 프레임워크는 아키텍처가 될수 없다.

### 혼인 관계의 비대칭성

* 당신은 프레임워크를 위해 큰 헌신을 해야하지만, 프레임워크 제작자는 당신을 위해 헌신하지않는다.
* 프레임워크와 당신의 관계는 일방적이다, 모든 위험과 부담은 당신이 감수할 뿐, 제작자가 감수하는 건 아무것도 없다.

### 위험 요인

* 프레임워크의 아키텍처가 의존성 규칙을 위반하는 경향이 있다
    * 프레임워크 제작자의 코드를 상속할 것을 요구한다.
    ```csharp
    //유니티에서 게임오브젝트
    public class PlayerUnit : MonoBehaviour
    {
    }
    ```
    * 프레임워크가 당신의 가장 안쪽 원과 결합되기를 원한다.
* 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어날것이다.
* 프레임워크가 신규버전으로 업그레이드되며 사용중이던 기능이 사라지거나 반영되기 힘든 형태로 변경될수 있다.
* 새롭고 더 나은 프레임 워크가 등장해서 갈아타고 싶을 수도 있다.

### 해결책

* 프레임워크와 결혼하지말라!
* 프레임워크가 핵심 코드 안으로 들어오지 못하게 하라.

### 이제 선언합니다

* 정말로 결혼해야 하는 프레임워크도 존재한다
    * C++ - STL
    * java - java 표준 라이브러리
* 애플리케이션이 프레임워크와 결혼하고자 하면 남은 생애동안 항상 함께 해야한다.
* 게임개발? 유니티와 결혼


# 33장, 사례연구: 비디오 판매

### 유스케이스 분석

* 시스템을 분할하여, 특정액터를 위한 변경이 나머지 액터에게 영향을 미치지않게 만들어야한다.
* 액터와 유스케이스를 식별

### 컴포넌트 아키텍처 

* 각 컴포넌트를 독립적으로 컴파일, 빌드가능한 환경을 구상하면 시스템이 변경되는 양상에 맞춰 시스템 배포방식을 조정할수있다.

### 의존성 관리

* 제어흐름은 오른쪽에서 왼쪽으로 이동한다. (컨트롤러 -> 뷰)
    * 입력이 컨트롤러에서 발생 -> 프레젠터가 결과의 포맷 변경 -> 뷰가 화면 표시
* 저수준의 세부사항에서 발생한 변경이 상위로 파급되어서 상위수준의 정책에 영향을 미치지 않음

