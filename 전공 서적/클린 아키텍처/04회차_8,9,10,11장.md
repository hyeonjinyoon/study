# 8장, OCP: 개방-폐쇄 원칙

### 요약

* 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
* 시스템을 컴포넌트 단위로 분리한다.
* 저수준 컴포넌트에서 발새한 변경으로부터 고수준 컴포넌트를 보호하는 의존성 계층구조가 만들어져야한다.

# 9장, LSP: 리스코프 치환 원칙

### 정의
* S 타입의 객체 o1 각각에 대응하는 T타입 객체 o2가 있고, 
  T타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도
  P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
 
### 요약
* 객체 지향의 초창기에는 LSP는 상속의 가이드로 간주되었다.
* 치환 가능성을 조금이라도 위배하면 상당량의 별도 메커니즘을 추가해야 할수도 있다.

# 10장, ISP: 인터페이스 분리 원칙

### 요약
* 다수의 클래스가 상위 클래스를 상속받을때 서로 전혀 사용하지 않는 소스코드가 있는 문제의 해결책
* ISP를 사용하는 근본적인 동기
    * 필요이상으로 많은 걸 포함한 모듈에 의존하는 것은 해롭다. -> 불필요한 재컴파일과 재배포를 강제
    * 고수준인 아키텍처 수준에서도 상황이 같기때문
* 13장 컴포넌트 응집도에서 더 자세히 다룸

# 11장, DIP: 의존성 역전 원칙

### 유연성이 극대화된 시스템
* 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.

### 안정된 추상화
* 이 원칙에서 전달하려는 구체적인 코딩 실천법 요약
    * 변동성이 큰 구체 클래스를 참조하지 말라.
    * 변동성이 큰 구체 클래스로부터 파생하지 말라.
    * 구체 함수를 오버라이드 하지 말라.
    * 구체적이며 변동성이 크다면 절대로 그이름을 언급하지 말라.

### 정리
* 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일을 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻
* 뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스를 변경하지 않고도 구현체에 기능을 추가 할 수 있는 방버을 찾기 위해 노력한다